{
  "hash": "2895f9eb760de17ba1aff6abc6712e23",
  "result": {
    "markdown": "---\ntitle: \"Reshaping Data with tidyr\"\nauthor: \"Keith Baxelbaum, Rose Hartman, and <br> Alexis Zavez <br>\"\ninstitute: \"Data Science and Biostatistics Unit (DSBU) and <br> Arcus Education, DBHI\"\ndate: \"2024-05-06\"\n---\n\n\n-   Use keyboard arrow keys to\n    -   advance ( → ) and\n    -   go back ( ← )\n-   Type \"s\" to see speaker notes\n-   Type \"?\" to see other keyboard shortcuts\n\n\n::: {.cell}\n\n:::\n\n\n## Join the CHOP R User Group\n\n::: {.columns .v-center-container}\n::: {.column width=\"50%\"}\n![](media/chopr.png){fig-alt=\"CHOPR hex sticker logo\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n-   Friendly help troubleshooting your R code\n-   Announcements for upcoming talks, workshops, and conferences\n:::\n:::\n\nLink to join: <https://bit.ly/chopRusers>\n\n::: notes\nJust a few announcements before we get started. For anyone here today that isn't already part of the CHOP R User group, I strongly encourage you to join (it is also open to Penn folks). The CHOP R User group has more than 400 members from all departments. This is great place to network with other R users, get help with coding problems, and learn about new packages, webinars, and conferences. We also have semi-regular meetings and workshops, like this one.\n:::\n\n## Come to R Office Hours!\n\n-   Set up a meeting to get live help with your R code from our most experienced useRs\n-   Office hours appointments can be one-on-one or open to the community\n\nLink to calendar: <https://bit.ly/chopROfficeHours>\n\n::: aside\nWe're looking for more volunteers to lead appointments! Get in touch: hartmanr1\\@chop.edu\n:::\n\n::: notes\nWe have regular office hours appointments available to get R help. We're offering two kinds of appointments: one-on-one, if you want individual help, or open appointments that are more of a community conversation about whatever R questions people bring up that day. The open appointments can be particularly valuable to attend if you want to hear other people's questions about R but maybe don't have a project of your own that you're troubleshooting at the moment. We set up a calendar online where you can book an appointment. \\[click\\] And if you like this idea and you're an experienced R user yourself, consider joining us to offer appointments! It's just whatever times work for you, so we can set up a schedule around whatever other work you've got going on. Reach out to me via email or slack for details.\n:::\n\n## Coming Soon - More R102 Sessions!\n\nThis is the third talk in a new series called **R102: MasteRing the Fundamentals**\n\n<br>\n\n**Next up:** Data Types and Visualizations, June 3rd 12:00pm ET\n\n<br>\n\nLearn more about this new series, including dates and titles for each session: <br> <https://arcus.github.io/r102/>\n\n::: notes\nToday's talk is the third in a series called **R102: MasteRing the Fundamentals**. These workshops are intended as a continuation of the popular Intro to R for Clinical Data workshop we offer a few times a year. Last month, we covered the first topic in this series: Missing values in R. Next month, we will cover: Data Types and Visualizations\n\nWe're designing these talks with beginners in mind, so if you're trying to figure out how to get started with R, or how to start applying it in your own work, these talks are for you! To see the schedule of talks, check out the website for the series. We'll also post links to slides and recordings there as well as they become available.\n:::\n\n# R 102: <br> Reshaping Data with tidyr\n\n::: notes\nToday's talk is a quick primer on some tools for data manipulation. If you've had a little exposure to R before, such as through an Intro to R for Clinical Data workshop, this is hopefully the right level for you now. If you're completely brand new to R, first of all: Welcome! You may find it tricky to actively follow along with the code today since I'm going to skim over some of the initial steps, but go ahead and give it a try, or just listen and watch if that feels more like the right speed.\n\nOur topic is how to turn your messy dataset or datasets into a well-structured, analysis-ready format. Data come to use in all manner of disarray, often due to reasons beyond our control -- a collaborator loves hand-curated Excel spreadsheets, or REDCap spit out data with a zillion columns, or we have data from five different clinical sources that we need to somehow link. This talk will start to explore efficient ways to wrestle data into a consistent, easy-to-use format called tidy data. These are big tasks, and we only scratch the surface of how to accomplish them.\n\nPlease feel free to put any questions in the chat - we have a few additional team members who will try to answer your questions during the talk. If there is extra time, we can also stop and talk about things as a group.\n:::\n\n## What we're covering today\n\n. . .\n\n-   What does it mean to have tidy data?\n\n. . .\n\n-   How to reshape data and how to extract multiple observations from a single cell\n\n. . .\n\n-   Some basic ways to combine multiple datasets\n\n. . .\n\n-   NOT manipulating data itself (e.g. imputing missing data), creating new variables, complex joins\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\n::: notes\nHere's some sample data from the tidyverse library that demonstrates different ways of presenting the same data (here, a small subset of data on TB cases by country in 1999 and 2000).\n\nWe'll see how the exame same data can be put into a tabular format in really different ways. For example, here in table 1 is one presentation of these data, where each row is one country in one year, and there are separate columns for each variable of interest (here, TB cases and population).\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\n::: notes\nHere are those same data, but in a differently formatted table. Table 2 has each year for each country, but rather than separate columns for cases and population, it has a single column with these data, and separate rows for cases and population, identified in the \"type\" column. All the same information is present, but it's stored in a different format!\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n\n::: notes\nHere's yet another way of storing those same data! Table 3 has all the same information, with each country/year pair in a row, but now rather than separate rows for cases and population, these are combined into a single \"rate\" column. This still has all the same information, as we could conceivably extract either the number of cases or the overall population if we wanted to, but it does so using one fewer column.\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country         `1999`     `2000`\n  <chr>            <dbl>      <dbl>\n1 Afghanistan   19987071   20595360\n2 Brazil       172006362  174504898\n3 China       1272915272 1280428583\n```\n:::\n:::\n\n:::\n:::\n\n::: notes\nStill other formats are possible too -- e.g. having separate columns for each year, storing cases in one table and population in another, and so on.\n\nRemember, in each of these cases we have the same information -- we haven't lost data in any case! However, not all formats are equally easy to use! A lot of tools within R, and especially within the tidyverse family of R packages, expect a specfic format called tidy data.\n:::\n\n## What is tidy data?\n\n. . .\n\n-   Variables = columns\n-   Observations = rows\n-   Values = cells; One value per cell!\n\n. . .\n\n**Consistent formatting helps:**\n\n-   ensure functions operate consistently on our data (think TIDYverse)\n-   ensure WE know what to expect in our data\n\n::: notes\nTidy data is a very specific, consistent way to format data that ensures we know exactly what to expect in our data. This is important and useful for multiple reasons. First, if data are consistently formatted the same way, then we can be confident in how functions will interact with these data. In the tidyverse (and increasingly other packages in R), the expectation is that data are in tidy format. This helps us get consistent output from the same functions!\n\nSecond, consistent data formatting helps us know what to expect from our data! If we always have one observation per row and one row per observation, then we can immediately know how to parse our data. If we know that each variable has its own column, then we know that we don't have to try to unpack complex columns to understand what the data are.\n:::\n\n## Getting data into tidy format\n\n-   What to do when multiple variables' values are in a single column?\n-   What to do when repeated measures (multiple observations of the same variable) are in the same row?\n-   What to do when a single cell contains more than one observation?\n\n::: notes\nA dataframe could be untidy in lots of ways (recall Hadley's quote a few slides ago). We're going to focus on three very common forms of untidy data, and discuss relatively simple ways to remedy them using tools from the tidyr package (part of the tidyverse).\n\nOne of the best things about R is there are always multiple ways to do the thing you want to do; this is also one of the worst things about R! But the tools in tidyr give us a standardized approach to reshaping our data, which gets rid of some of the decision points and variability in our coding style.\n:::\n\n# Using pivot wider to spread data across more columns\n\n::: notes\nFirst, we'll talk about a situation in which we don't have separate columns for each variable.\n:::\n\n## Pivot wider\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n:::\n:::\n\n\n. . . \n\n**The problem:** The count column has data for both the cases and population variables!\n\n::: notes\nThe first reshaping challenge we'll address is when variables are specified in rows, rather than in columns. Recall that tidy data means that each variable has its own column, and rows are reserved for unique observations of these variables. But data don't always come in this way.\n\nRecall the structure of table2 from earlier (this table is pre-loaded as part of the tidyverse package if you want to play with it). In this table, the \"type\" column is used to identify which variable a row is talking about, and then the \"count\" column contains the value for that variable for that observation. This isn't what we want for tidy data; in particular, we want the values for population and for cases for a given country in a given year to be on the same row -- this is one \"observation,\" so they shouldn't be separated.\n\nA great hint that your data may have this issue is if a column with data includes different types of data or things on really different scales (e.g. here, the population rows are several orders of magnitude larger than the cases rows). In this case, we want to spread these variables out to be in their own columns rather than sharing a column.\n:::\n\n\n## Pivot wider\n\nEnter the `pivot_wider` function!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1|3|4|5|\"}\nlibrary(tidyr)\n\ndf <- pivot_wider(table2, \n                  values_from = count,\n                  names_from = type)\n```\n:::\n\n\n**`pivot_wider` arguments:**\n\n-   Dataframe with the original, unpivoted data\n-   `values_from`: the name of the column with the data values\n-   `names_from`: the name of the column that identifies which variable is represented in the data column\n\n::: notes\nA great way to do this is using the pivot_wider function. This function is part of the tidyr package, which is full of useful tools for tidying up your data. pivot_wider is used to spread out data from one column into separate columns. The additional piece of the puzzle is naming these new columns so we know what they show us. pivot_wider asks you both where the data should come from, as well as where the names are!\n\nFirst, you specify the dataframe your data that need pivoting are in.\n\nThen, you specify which column contains the data themselves using \"values_from = column_name\".\n\nFinally, you specify the column that contains the names you want to use for the new data columns using \"names_from = column_name\".\n:::\n\n## Pivot wider\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year type           count\n  <chr>       <dbl> <chr>          <dbl>\n1 Afghanistan  1999 cases            745\n2 Afghanistan  1999 population  19987071\n3 Afghanistan  2000 cases           2666\n4 Afghanistan  2000 population  20595360\n5 Brazil       1999 cases          37737\n6 Brazil       1999 population 172006362\n```\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_wider(table2, values_from = count, names_from = type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n\n::: notes\nNow our data are nice and tidy! The different variables for cases and population are in their own columns, and each row is a single observation of all the variables -- e.g. row 1 is the values of these variables in Afghanistan in the year 1999. The next row is a new observation -- it's the values in Afghanistan, but now in 2000.\n:::\n\n## {{< fa rocket >}} Coding Challenge 1\n\n::: r-fit-text\nYour turn!\n\nLook in the `tidyr_exercises.rmd` file to find your first coding\nchallenge.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"countdown\" id=\"timer_46aa5a8c\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">02</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n:::\n:::\n\n\n::: notes\nWe'll just work on this for a couple minutes and if you don't finish\nduring that time, no sweat, just pause wherever you are and we'll take a\nlook at the solutions together.\n:::\n\n## Pivot wider's other functionality\n\n`pivot_wider` has a variety of other optional arguments:\n\n`pivot_wider( data, …, id_cols = NULL, id_expand = FALSE, names_from = name, names_prefix = \"\", names_sep =\"_\", names_glue = NULL, names_sort = FALSE, names_vary =\"fastest\", names_expand = FALSE, names_repair = \"check_unique\", values_from = value, values_fill = NULL, values_fn = NULL, unused_fn = NULL )`\n\n::: notes\nThe function notes for pivot_wider, accessible by putting a question mark before the function name, show a number of other options available in pivot_wider. These let you automate a bunch of other things you might need to do for more complex pivots. We won't go through all of these, but the documentation can guide you to some other functionality. In particular, these other arguments are helpful when you need to widen multiple data columns rather than just one; there are lots of useful tools for making sure your output is still named coherently and that you are only pivoting the columns you want to.\n\nAnother useful additional option is the values_fill argument. This argument lets you specify what to put if a specific observation is missing -- e.g. if we had the number of cases for Brazil in 1999 but we didn't have a row for the population in Brazil in 1999. The default is to mark these as missing, so they'll appear as an NA value. But you can use the values_fill argument to give different options -- e.g. perhaps you want any missing values to be entered as 0 instead of missing.\n:::\n\n# Using pivot longer to gather observations of the same variable into rows\n\n::: notes\nNext, we'll talk about a situation in the same variable has observations spread across columns rather than across rows.\n:::\n\n## Pivot longer\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n:::\n:::\n\n\n. . . \n\n**The problem:** The same variable (number of cases) is in multiple columns! Not just one observation per row!\n\n::: notes\nAnother challenge that often arises is that data are spread across columns such that multiple observations occur in the same row. For example, in this format of the TB case data, there are separate columns for the same variable in different years. This data format comes up a lot, especially for things like longitudinal data, where we measure the same thing at multiple timepoints. It sometimes feels natural to give each patient their own row, and then list all their measurements in columns across the row (like this table does with each country and measures at each year).\n\nThis data format isn't wrong, but it's not tidy -- each row represents more than one observation. In these cases, the data is too wide -- so we don't want to pivot it wider, but we want to make it longer.\n:::\n\n## Pivot longer\n\nEnter the `pivot_longer` function!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1|2|\"}\ndf_cases <- pivot_longer(table4a, \n                  cols = `1999`:`2000`)\n```\n:::\n\n\n**`pivot_longer` arguments:**\n\n-   Dataframe with the original, unpivoted data\n-   `cols`: The set of column names with the data that you want to lengthen. \n\n::: notes\nThe pivot_longer function does just this -- it pivots the data in the opposite direction, creating new rows based on the columns we say to pivot.\n\nThis function only requires two arguments: the dataframe with the data you want to pivot, and a cols argument that says which columns you want to pivot. This latter argument should be the set of columns that have the repeated observations you want to put into a single output column.\n:::\n\n## Pivot longer\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table4a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_longer(table4a, cols = `1999`:`2000`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country     name   value\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n:::\n:::\n\n\n::: notes\nNow our data are nice and tidy! Each observation has its own row -- one row per country per year! And there is a single column for the number of TB cases. The function got the values for the \"name\" column from the column names in the unpivoted dataframe -- so it found the value in each of the columns you told it to pivot, and then marked which column that data came from.\n\nThis worked great, but the column names leave something to be desired -- the defaults for pivot_longer always call the data column \"value\" and the specifier column \"name\". These are very uninformative column names! Thankfully, there some other arguments in pivot_longer that can fix this for us.\n:::\n\n## Pivot longer\n\nSome QOL arguments availabile in pivot_longer!\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table4a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_longer(table4a, cols = `1999`:`2000`, \n             names_to = \"year\", \n             values_to = \"cases\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country     year   cases\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n:::\n:::\n\n\n::: notes\nThe names_to argument lets us specify what to call the column that stores the previous column names. The values_to argument lets us specify what to call the column that stores the values.\n:::\n\n## {{< fa rocket >}} Coding Challenge 2\n\n::: r-fit-text\nYour turn!\n\nLook in the `tidyr_exercises.rmd` file to find your next coding\nchallenge.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"countdown\" id=\"timer_75ba463f\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">02</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n:::\n:::\n\n\n::: notes\nWe'll just work on this for a couple minutes and if you don't finish\nduring that time, no sweat, just pause wherever you are and we'll take a\nlook at the solutions together.\n:::\n\n## Pivot longer's other functionality\n\n`pivot_longer` has a variety of other optional arguments:\n\n`pivot_longer(\n  data,\n  cols,\n  ...,\n  cols_vary = \"fastest\",\n  names_to = \"name\",\n  names_prefix = NULL,\n  names_sep = NULL,\n  names_pattern = NULL,\n  names_ptypes = NULL,\n  names_transform = NULL,\n  names_repair = \"check_unique\",\n  values_to = \"value\",\n  values_drop_na = FALSE,\n  values_ptypes = NULL,\n  values_transform = NULL\n)`\n\n::: notes\nThe function notes for pivot_longer, accessible by putting a question mark before the function name, show a number of other options available in pivot_longer. We won't go through all of these, but the documentation can guide you to some other functionality. \n\nOne worth noting is the values_drop_na argument. This lets you decide what to do if there are missing values in your data as you pivot it. The default is to keep those NA values -- so for example, if we were missing the number of TB cases in China in 2000, after pivoting we would still have a row for China in 2000, but the value for cases would be NA. If you'd rather not create such rows, you can set values_drop_na to true.\n:::\n\n\n# Splitting multiple values contained in the same cell\n\n## Separating multiple variables in a single cell\n\nSometimes multiple variables end up combined in your dataframe.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n**The problem:** The rate column includes both cases and population variables!\n\n::: notes\nSometimes our data come in in a way that we have multiple different variables in the same cell. This could be something like table 3 here, where rather than separating cases and population, they're presented in a single cell as a ratio. This may be useful for some analyses, but not for others -- what if we want to investigate population change irrespective of cases? What if we want to split data on the basis of population (small, medium, large)? For these (and other) uses, it's helpful to have each variable on its own. We can always compute a ratio later!\n\nWe might also encounter this situation with things like medication dosage, if we have the dose and the units in the same column -- maybe one patient received 100 micrograms, but another received 10 mg. It's often easier to convert these if we have the numeric dose in one column, and the units in another. \n\nThis means that in situations like this, it's often helpful to split the offending column of combined variables into separate columns. Let's look into some options for doing so!\n:::\n\n## Separating multiple variables in a single cell\nOften idiosyncratic to your specific dataset, but a family of useful functions:\n\n-   `separate_longer_delim`\n-   `separate_longer_position`\n-   `separate_wider_delim`\n-   `separate_wider_position`\n\n::: notes\nThis set of functions allows you to take the contents of one column and split them into either multiple columns (separate_wider) or separate rows (separate_longer). They also let you decide whether to split based on a specific delimiter -- a character that shows where the breaks between values are -- or based on a given width -- a count of the number of characters in each value.\n\nYou'll need to think carefully about which of these applies to your data!\n:::\n\n\n## Separating multiple variables in a single cell\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nWhich should use to get tidy data? Vote in the comments! \n\n-   separate_longer_delim\n-   separate_longer_position\n-   separate_wider_delim\n-   separate_wider_position\n:::\n:::\n\n## Separating multiple variables in a single cell\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nseparate_wider_delim(table3,\n   cols = rate,\n   delim = \"/\",\n   names = c(\"cases\", \"population\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  country      year cases  population\n  <chr>       <dbl> <chr>  <chr>     \n1 Afghanistan  1999 745    19987071  \n2 Afghanistan  2000 2666   20595360  \n3 Brazil       1999 37737  172006362 \n4 Brazil       2000 80488  174504898 \n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n:::\n:::\n\n:::\n:::\n\n# Combining data from multiple tables\n\n## Combining data\n\n-   Sometimes we need to combine data from more than one dataset. What to do?\n-   Extra rows of data We could use rbind...\n-   Extra columns of data We could use cbind....\n-   Extra information about the data from a different shaped dataset Now we see the real limitations of the binds. We need to use joins!\n\n## Left joins\n\n-   Some assumptions! One-to-one or many-to-one. Not one-to-many or many-to-many!\n\n## Other types of joins\n\n-   Right joins\n-   Outer joins\n-   Inner joins\n-   Anti-joins\n-   Semi-joins\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}