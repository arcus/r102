{
  "hash": "6621b15e4d78564b5ec380418e2ef9c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Reshaping Data with tidyr\"\nauthor: \"Keith Baxelbaum, Rose Hartman, and <br> Alexis Zavez <br>\"\ninstitute: \"Data Science and Biostatistics Unit (DSBU) and <br> Arcus Education, DBHI\"\ndate: \"2024-05-06\"\n---\n\n\n-   Use keyboard arrow keys to\n    -   advance ( → ) and\n    -   go back ( ← )\n-   Type \"s\" to see speaker notes\n-   Type \"?\" to see other keyboard shortcuts\n\n\n::: {.cell}\n\n:::\n\n\n## Join the CHOP R User Group\n\n::: {.columns .v-center-container}\n::: {.column width=\"50%\"}\n![](media/chopr.png){fig-alt=\"CHOPR hex sticker logo\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n-   Friendly help troubleshooting your R code\n-   Announcements for upcoming talks, workshops, and conferences\n:::\n:::\n\nLink to join: <https://bit.ly/chopRusers>\n\n::: notes\nJust a few announcements before we get started. For anyone here today that isn't already part of the CHOP R User group, I strongly encourage you to join (it is also open to Penn folks). The CHOP R User group has more than 400 members from all departments. This is great place to network with other R users, get help with coding problems, and learn about new packages, webinars, and conferences. We also have semi-regular meetings and workshops, like this one.\n:::\n\n## Come to R Office Hours!\n\n-   Set up a meeting to get live help with your R code from our most experienced useRs\n-   Office hours appointments can be one-on-one or open to the community\n\nLink to calendar: <https://bit.ly/chopROfficeHours>\n\n::: aside\nWe're looking for more volunteers to lead appointments! Get in touch: hartmanr1\\@chop.edu\n:::\n\n::: notes\nWe have regular office hours appointments available to get R help. We're offering two kinds of appointments: one-on-one, if you want individual help, or open appointments that are more of a community conversation about whatever R questions people bring up that day. The open appointments can be particularly valuable to attend if you want to hear other people's questions about R but maybe don't have a project of your own that you're troubleshooting at the moment. We set up a calendar online where you can book an appointment. \\[click\\] And if you like this idea and you're an experienced R user yourself, consider joining us to offer appointments! It's just whatever times work for you, so we can set up a schedule around whatever other work you've got going on. Reach out to me via email or slack for details.\n:::\n\n## Coming Soon - More R102 Sessions!\n\nThis is the third talk in a new series called **R102: MasteRing the Fundamentals**\n\n<br>\n\n**Next up:** Data Types and Visualizations, June 3rd 12:00pm ET\n\n<br>\n\nLearn more about this new series, including dates and titles for each session: <br> <https://arcus.github.io/r102/>\n\n::: notes\nToday's talk is the third in a series called **R102: MasteRing the Fundamentals**. These workshops are intended as a continuation of the popular Intro to R for Clinical Data workshop we offer a few times a year. Last month, we covered the first topic in this series: Missing values in R. Next month, we will cover: Data Types and Visualizations\n\nWe're designing these talks with beginners in mind, so if you're trying to figure out how to get started with R, or how to start applying it in your own work, these talks are for you! To see the schedule of talks, check out the website for the series. We'll also post links to slides and recordings there as well as they become available.\n:::\n\n## Update your R!\n\nRecent discovery of vulnerabilities in R. \n\n**Make sure to update to the most recent version (4.4.0).**\n\nDetails at: https://nvd.nist.gov/vuln/detail/CVE-2024-2732\n\n\n# Shameless Plug\n\n**Have a funded research project and need some additional help from an experienced biostatistician or data scientist to analyze your data?**\n<br>\n<br>\n\n. . .\n\nThe Data Science and Biostatistics Unit (DSBU) is DBHi’s and CHOP Research Institute’s centralized service unit for biostatistics and data science analysis support. Reach out to Alexis Zavez (zaveza\\@chop.edu) or Keith Baxelbaum (baxelbaumk\\@chop.edu) for more info! \n\n\n# R 102: <br> Reshaping Data with tidyr\n\n::: notes\nToday's talk is a quick primer on some tools for data manipulation. If you've had a little exposure to R before, such as through an Intro to R for Clinical Data workshop, this is hopefully the right level for you now. If you're completely brand new to R, first of all: Welcome! You may find it tricky to actively follow along with the code today since I'm going to skim over some of the initial steps, but go ahead and give it a try, or just listen and watch if that feels more like the right speed.\n\nOur topic is how to turn your messy dataset or datasets into a well-structured, analysis-ready format. Data come to use in all manner of disarray, often due to reasons beyond our control -- a collaborator loves hand-curated Excel spreadsheets, or REDCap spit out data with a zillion columns, or we have data from five different clinical sources that we need to somehow link. This talk will start to explore efficient ways to wrestle data into a consistent, easy-to-use format called tidy data. These are big tasks, and we only scratch the surface of how to accomplish them.\n\nPlease feel free to put any questions in the chat - we have a few additional team members who will try to answer your questions during the talk. If there is extra time, we can also stop and talk about things as a group.\n:::\n\n## Today's plan!\n\n**What we're covering:**\n. . .\n\n-   What does it mean to have tidy data?\n\n. . .\n\n-   How to reshape data and how to extract multiple observations from a single cell\n\n. . .\n\n**What we're not covering:**\n\n-   Manipulating data (e.g. imputing missing data, combining variables), creating new variables, joining multiple datasets\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n::: notes\nHere's some sample data from the tidyverse library that demonstrates different ways of presenting the same data (here, a small subset of data on TB cases by country in 1999 and 2000).\n\nWe'll see how the exame same data can be put into a tabular format in really different ways. For example, here in table 1 is one presentation of these data, where each row is one country in one year, and there are separate columns for each variable of interest (here, TB cases and population).\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n:::\n\n\n::: notes\nHere are those same data, but in a differently formatted table. Table 2 has each year for each country, but rather than separate columns for cases and population, it has a single column with these data, and separate rows for cases and population, identified in the \"type\" column. All the same information is present, but it's stored in a different format!\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n\n::: notes\nHere's yet another way of storing those same data! Table 3 has all the same information, with each country/year pair in a row, but now rather than separate rows for cases and population, these are combined into a single \"rate\" column. This still has all the same information, as we could conceivably extract either the number of cases or the overall population if we wanted to, but it does so using one fewer column.\n:::\n\n## How should we structure our data?\n\n`“Tidy datasets are all alike, but every messy dataset is messy in its own way.” Hadley Wickham`\n\nThe same data can be presented in various formats.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country         `1999`     `2000`\n  <chr>            <dbl>      <dbl>\n1 Afghanistan   19987071   20595360\n2 Brazil       172006362  174504898\n3 China       1272915272 1280428583\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: notes\nStill other formats are possible too -- e.g. having separate columns for each year, storing cases in one table and population in another, and so on.\n\nRemember, in each of these cases we have the same information -- we haven't lost data in any case! However, not all formats are equally easy to use! A lot of tools within R, and especially within the tidyverse family of R packages, expect a specfic format called tidy data.\n:::\n\n## What is tidy data?\n\n. . .\n\n-   Variables = columns\n-   Observations = rows\n-   Values = cells; One value per cell!\n\n. . .\n\n**Consistent formatting helps:**\n\n-   ensure functions operate consistently on our data (think TIDYverse)\n-   ensure WE know what to expect in our data\n\n::: notes\nTidy data is a very specific, consistent way to format data that ensures we know exactly what to expect in our data. This is important and useful for multiple reasons. First, if data are consistently formatted the same way, then we can be confident in how functions will interact with these data. In the tidyverse (and increasingly other packages in R), the expectation is that data are in tidy format. This helps us get consistent output from the same functions!\n\nSecond, consistent data formatting helps us know what to expect from our data! If we always have one observation per row and one row per observation, then we can immediately know how to parse our data. If we know that each variable has its own column, then we know that we don't have to try to unpack complex columns to understand what the data are.\n:::\n\n## Getting data into tidy format\n\n-   What to do when multiple variables' values are in a single column?\n-   What to do when repeated measures (multiple observations of the same variable) are in the same row?\n-   What to do when a single cell contains more than one observation?\n\n::: notes\nA dataframe could be untidy in lots of ways (recall Hadley's quote a few slides ago). We're going to focus on three very common forms of untidy data, and discuss relatively simple ways to remedy them using tools from the tidyr package (part of the tidyverse).\n\nOne of the best things about R is there are always multiple ways to do the thing you want to do; this is also one of the worst things about R! But the tools in tidyr give us a standardized approach to reshaping our data, which gets rid of some of the decision points and variability in our coding style.\n:::\n\n# Using pivot wider to spread data across more columns\n\n::: notes\nFirst, we'll talk about a situation in which we don't have separate columns for each variable.\n:::\n\n## Pivot wider\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n:::\n\n\n. . . \n\n**The problem:** The count column has data for both the cases and population variables!\n\n::: notes\nThe first reshaping challenge we'll address is when variables are specified in rows, rather than in columns. Recall that tidy data means that each variable has its own column, and rows are reserved for unique observations of these variables. But data don't always come in this way.\n\nRecall the structure of table2 from earlier (this table is pre-loaded as part of the tidyverse package if you want to play with it). In this table, the \"type\" column is used to identify which variable a row is talking about, and then the \"count\" column contains the value for that variable for that observation. This isn't what we want for tidy data; in particular, we want the values for population and for cases for a given country in a given year to be on the same row -- this is one \"observation,\" so they shouldn't be separated.\n\nA great hint that your data may have this issue is if a column with data includes different types of data or things on really different scales (e.g. here, the population rows are several orders of magnitude larger than the cases rows). In this case, we want to spread these variables out to be in their own columns rather than sharing a column.\n:::\n\n\n## Pivot wider\n\nEnter the `pivot_wider` function!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1|3|4|5|\"}\nlibrary(tidyr)\n\ndf <- pivot_wider(table2, \n                  values_from = count,\n                  names_from = type)\n```\n:::\n\n\n**`pivot_wider` arguments:**\n\n-   Dataframe with the original, unpivoted data\n-   `values_from`: the name of the column with the data values\n-   `names_from`: the name of the column that identifies which variable is represented in the data column\n\n::: notes\nA great way to do this is using the pivot_wider function. This function is part of the tidyr package, which is full of useful tools for tidying up your data. pivot_wider is used to spread out data from one column into separate columns. The additional piece of the puzzle is naming these new columns so we know what they show us. pivot_wider asks you both where the data should come from, as well as where the names are!\n\nFirst, you specify the dataframe your data that need pivoting are in.\n\nThen, you specify which column contains the data themselves using \"values_from = column_name\".\n\nFinally, you specify the column that contains the names you want to use for the new data columns using \"names_from = column_name\".\n:::\n\n## Pivot wider\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year type           count\n  <chr>       <dbl> <chr>          <dbl>\n1 Afghanistan  1999 cases            745\n2 Afghanistan  1999 population  19987071\n3 Afghanistan  2000 cases           2666\n4 Afghanistan  2000 population  20595360\n5 Brazil       1999 cases          37737\n6 Brazil       1999 population 172006362\n```\n\n\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_wider(table2, values_from = count, names_from = type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n::: notes\nNow our data are nice and tidy! The different variables for cases and population are in their own columns, and each row is a single observation of all the variables -- e.g. row 1 is the values of these variables in Afghanistan in the year 1999. The next row is a new observation -- it's the values in Afghanistan, but now in 2000.\n:::\n\n## Compatible with piping!\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable2 |>\n  pivot_wider(values_from = count, names_from = type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\nYou can use the \"pipe\" operator for this if you're used to piping. The pipe (`|>`) sends the value on the left of the pipe to serve as the first argument in the function on the right of the pipe.\n\n\n## {{< fa rocket >}} Coding Challenge 1\n\n::: r-fit-text\nYour turn!\n\nLook in the `reshaping_data_exercises.rmd` file to find your first coding\nchallenge.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"timer_de9a0c5e\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">02</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n\n\n::: notes\nWe'll just work on this for a couple minutes and if you don't finish\nduring that time, no sweat, just pause wherever you are and we'll take a\nlook at the solutions together.\n:::\n\n\n## {{< fa book-open >}} Learn more\n\npivot_wider has lots of other functionality that we won't cover today. This includes options for renaming things, pivoting multiple columns simultaneously, and filling in missing values with default values. To learn more:\n\n-   [Code documentation](https://tidyr.tidyverse.org/reference/pivot_wider.html)\n-   [Vignettes on pivoting](https://tidyr.tidyverse.org/articles/pivot.html)\n\n::: notes\nThere are a few \"learn more\" slides throughout the\npresentation. They include links to resources to learn more\nabout the topics we're covering. I won't click through to any of these\nresources now, but you have access to the slides so feel free to go back\nand review these links later if you like!\n:::\n\n\n# Using pivot longer to gather observations of the same variable into rows\n\n::: notes\nNext, we'll talk about a situation in the same variable has observations spread across columns rather than across rows.\n:::\n\n## Pivot longer\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntable4a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n\n. . . \n\n**The problem:** The same variable (number of cases) is in multiple columns! Not just one observation per row!\n\n::: notes\nAnother challenge that often arises is that data are spread across columns such that multiple observations occur in the same row. For example, in this format of the TB case data, there are separate columns for the same variable in different years. This data format comes up a lot, especially for things like longitudinal data, where we measure the same thing at multiple timepoints. It sometimes feels natural to give each patient their own row, and then list all their measurements in columns across the row (like this table does with each country and measures at each year).\n\nThis data format isn't wrong, but it's not tidy -- each row represents more than one observation. In these cases, the data is too wide -- so we don't want to pivot it wider, but we want to make it longer.\n:::\n\n## Pivot longer\n\nEnter the `pivot_longer` function!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1|2|\"}\ndf_cases <- pivot_longer(table4a, \n                  cols = `1999`:`2000`)\n```\n:::\n\n\n**`pivot_longer` arguments:**\n\n-   Dataframe with the original, unpivoted data\n-   `cols`: The set of column names with the data that you want to lengthen. \n\n::: notes\nThe pivot_longer function does just this -- it pivots the data in the opposite direction, creating new rows based on the columns we say to pivot.\n\nThis function only requires two arguments: the dataframe with the data you want to pivot, and a cols argument that says which columns you want to pivot. This latter argument should be the set of columns that have the repeated observations you want to put into a single output column.\n:::\n\n## Pivot longer\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table4a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_longer(table4a, cols = `1999`:`2000`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country     name   value\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n\n\n:::\n:::\n\n\n::: notes\nNow our data are nice and tidy! Each observation has its own row -- one row per country per year! And there is a single column for the number of TB cases. The function got the values for the \"name\" column from the column names in the unpivoted dataframe -- so it found the value in each of the columns you told it to pivot, and then marked which column that data came from.\n\nThis worked great, but the column names leave something to be desired -- the defaults for pivot_longer always call the data column \"value\" and the specifier column \"name\". These are very uninformative column names! Thankfully, there some other arguments in pivot_longer that can fix this for us.\n:::\n\n## Pivot longer\n\nSome QOL arguments availabile in pivot_longer!\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table4a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  <chr>        <dbl>  <dbl>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n```\n\n\n:::\n:::\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\npivot_longer(table4a, cols = `1999`:`2000`, \n             names_to = \"year\", \n             values_to = \"cases\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country     year   cases\n  <chr>       <chr>  <dbl>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n```\n\n\n:::\n:::\n\n\n::: notes\nThe names_to argument lets us specify what to call the column that stores the previous column names. The values_to argument lets us specify what to call the column that stores the values.\n:::\n\n## {{< fa rocket >}} Coding Challenge 2\n\n::: r-fit-text\nYour turn!\n\nLook in the `reshaping_data_exercises.rmd` file to find your next coding\nchallenge.\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"timer_becf9d62\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">03</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n\n\n::: notes\nWe'll just work on this for a couple minutes and if you don't finish\nduring that time, no sweat, just pause wherever you are and we'll take a\nlook at the solutions together.\n:::\n\n## {{< fa book-open >}} Learn more\n\npivot_longer has lots of other functionality that we won't cover today. For example, there are arguments that help clean up names beyond what we've already seen, options to manipulate the data as you pivot, and options for what to do with missing values. To learn how to use these:\n\n-   [Code documentation](https://tidyr.tidyverse.org/reference/pivot_longer.html)\n-   [Vignettes on pivoting](https://tidyr.tidyverse.org/articles/pivot.html)\n\n::: notes\nThere are a few \"learn more\" slides throughout the\npresentation. They include links to resources to learn more\nabout the topics we're covering. I won't click through to any of these\nresources now, but you have access to the slides so feel free to go back\nand review these links later if you like!\n:::\n\n\n# Splitting multiple values contained in the same cell\n\n::: notes\nOur final reshaping topic for today is what to do when you have more than one measurement in a single cell. Tidy data expects one value per cell -- remember, each variable should be in its own column! But sometimes, you end up with data where multiple variables are combined in one cell and need to be separated. There are lots of ways to do this, but we'll cover a particularly handy set of tools from the tidyr package.\n\n:::\n\n## Separating multiple variables in a single cell\n\nSometimes multiple variables end up combined in your dataframe.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n**The problem:** The rate column includes both cases and population variables!\n\n::: notes\nSometimes our data come in in a way that we have multiple different variables in the same cell. This could be something like table 3 here, where rather than separating cases and population, they're presented in a single cell as a ratio. This may be useful for some analyses, but not for others -- what if we want to investigate population change irrespective of cases? What if we want to split data on the basis of population (small, medium, large)? For these (and other) uses, it's helpful to have each variable on its own. We can always compute a ratio later!\n\nOne place this pops up a lot is things like a list of languages that a patient speaks. Rather than have this as a series of separate entries, it might be entered as a list with commas separating values. These lists can be a huge pain to work with! In situations like this, it's often helpful to split the offending column of combined variables into separate columns. Let's look into some options for doing so!\n:::\n\n## Separating multiple variables in a single cell\nOften idiosyncratic to your specific dataset, but a family of useful functions from tidyr:\n\n-   `separate_longer_delim`\n-   `separate_longer_position`\n-   `separate_wider_delim`\n-   `separate_wider_position`\n\n::: notes\nThis set of functions allows you to take the contents of one column and split them into either multiple columns (separate_wider) or separate rows (separate_longer). They also let you decide whether to split based on a specific delimiter -- a character that shows where the breaks between values are -- or based on a given width -- a count of the number of characters in each value.\n\nYou'll need to think carefully about which of these applies to your data!\n:::\n\n\n## Separating multiple variables in a single cell\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nWhich should use to get tidy data? Vote in the comments! \n\n-   separate_longer_delim\n-   separate_longer_position\n-   separate_wider_delim\n-   separate_wider_position\n:::\n:::\n\n## Separating multiple variables in a single cell\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nhead(table3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nseparate_wider_delim(table3,\n cols = rate,\n delim = \"/\",\n names = c(\"cases\", \"population\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year cases  population\n  <chr>       <dbl> <chr>  <chr>     \n1 Afghanistan  1999 745    19987071  \n2 Afghanistan  2000 2666   20595360  \n3 Brazil       1999 37737  172006362 \n4 Brazil       2000 80488  174504898 \n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: notes\nIn this case, we likely want to use separate_wider_delim.\n\n-   wider because we are separating different variables (cases and populations) so we want to make new columns, not new rows.\n-   delim because we are separating by a delimiter (a slash), not by a specific number of characters.\n\nWhen we do this, we get a nice, tidy dataframe with separate columns for cases and populations (and those columns named using the names argument)\n\n:::\n\n## {{< fa book-open >}} Learn more\n\nThere's another member of this family of functions for more complex separation needs:\n`separate_wider_regex`\n\n-   [Code documentation](https://tidyr.tidyverse.org/reference/separate_wider_delim.html)\n-   [More info on regex](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html)\n\n::: notes\nThe separate_wider_regex function lets you write regular expressions to parse complex text in your cells in order to separate things that are more complicated. We won't cover this today -- regular expressions are really complicated and worthy of (at least) a full session on their own. But if you're feeling adventurous, check out these resources!\n:::\n\n\n## What have we learned today?\n\n. . .\n\n-   There are various ways to store data; the tidy format is quite useful!\n\n. . .\n\n-   `pivot_wider` can tidy datasets where multiple variables are presented in the same column.\n\n. . .\n\n-   `pivot_longer` can tidy datasets where multiple observations of the same variable are in the same row.\n\n. . .\n\n-   The `separate_` family of functions can tidy datasets where one cell has more than one piece of information.\n\n. . .\n\n## {{< fa rocket >}}  Capstone project!\nIn the exercises R markdown file, look in the `reshaping_data_exercises.Rmd` file at the capstone project to try to apply these tools to a more complex dataset, while having to write your code from scratch!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}